# Jump Game
Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Determine if you are able to reach the last index.

>The array `A` contains ğ‘› integers ğ‘1, ğ‘2, â€¦, ğ‘ğ‘› (1â‰¤ğ‘ğ‘–â‰¤5000) (1â‰¤nâ‰¤5000)

## Example1
Input:
```
A = [2,3,1,1,4]

```
Output:
```
true

```
Explanation:
```
0 -> 1 -> 4 (the number here is subscript) is a reasonable scheme.

```

## Example 2
Input:
```
A = [3,2,1,0,4]

```
Output:
```
false

```
Explanation:
```
There is no solution that can reach the end.

```

## Challenge

This problem have two method which is `Greedy` and `Dynamic` Programming.

The time complexity of `Greedy` method is O(n).

The time complexity of `Dynamic` Programming method is O(n^2).

We manually set the small data set to allow you pass the test in both ways. This is just to let you learn how to use this problem in dynamic programming ways. If you finish it in dynamic programming ways, you can try greedy method to make it accept again.

## Approach
```
è½¬ç§»æ–¹ç¨‹:

       è®¾ f[j] è¡¨ç¤ºé’è›™èƒ½ä¸èƒ½è·³åˆ°çŸ³å¤´ j


                   æšä¸¾ä¸Šä¸€ä¸ªè·³åˆ°çš„             æœ€åä¸€æ­¥çš„
                       çŸ³å¤´ i                 è·ç¦»ä¸èƒ½è¶…è¿‡ ai
                         |                      |    
                         |                      |    
          f[j] = OR (0 <= i < j) (f[i] AND + a[i] >= j]
            |                       |        
            |                       |
         ğŸ¸ èƒ½ä¸èƒ½                 ğŸ¸ èƒ½ä¸èƒ½
         è·³åˆ°çŸ³å¤´j                 è·³åˆ°çŸ³å¤´i         



   Time Complexity:  O(N^2)
   Space Complexity: O(N)

```

## Solution

```java
public class Solution {
    /**
     * @param A: A list of integers
     * @return: A boolean
     */
    public boolean canJump(int[] A) {
        // corner case
        if (A.length == 0 || A.length == 1) {
            return true;
        }

        // state
        int n =  A.length;
        boolean[] dp = new boolean[n];
        dp[0] = true;

        // function
        for (int i = 1; i < n; i++) {
            dp[i] = false;
            for (int j = 0; j < i; j++) {
                if(dp[j] && A[j] >= i - j) {
                    dp[i] = true;
                    break;
                }
            }
        }

        return dp[n - 1];
    }
}
```
